From 87bf7bcdeb3c652e3a2986a3f84f8f4ce5cb70e8 Mon Sep 17 00:00:00 2001
From: My Name <myemail@example.com>
Date: Sun, 8 Feb 2026 19:41:57 +0100
Subject: [PATCH] Add szkrabok tools

---
 tools/extract.js  |  35 ++++++++++++++++
 tools/interact.js |  23 +++++++++++
 tools/navigate.js |  27 ++++++++++++
 tools/session.js  | 103 ++++++++++++++++++++++++++++++++++++++++++++++
 tools/wait.js     |  28 +++++++++++++
 tools/workflow.js |  66 +++++++++++++++++++++++++++++
 6 files changed, 282 insertions(+)
 create mode 100644 tools/extract.js
 create mode 100644 tools/interact.js
 create mode 100644 tools/navigate.js
 create mode 100644 tools/session.js
 create mode 100644 tools/wait.js
 create mode 100644 tools/workflow.js

diff --git a/tools/extract.js b/tools/extract.js
new file mode 100644
index 0000000..2d17548
--- /dev/null
+++ b/tools/extract.js
@@ -0,0 +1,35 @@
+import * as pool from '../core/pool.js'
+import * as upstream from '../upstream/wrapper.js'
+
+export const text = async args => {
+  const { id, selector = null } = args
+  const session = pool.get(id)
+  const content = await upstream.getText(session.page, selector)
+  return { content }
+}
+
+export const html = async args => {
+  const { id, selector = null } = args
+  const session = pool.get(id)
+  const content = await upstream.getHtml(session.page, selector)
+  return { content }
+}
+
+export const screenshot = async args => {
+  const { id, path = null, fullPage = false } = args
+  const session = pool.get(id)
+  const buffer = await upstream.screenshot(session.page, { path, fullPage })
+
+  return {
+    success: true,
+    path,
+    base64: path ? null : buffer.toString('base64'),
+  }
+}
+
+export const evaluate = async args => {
+  const { id, code, args: evalArgs = [] } = args
+  const session = pool.get(id)
+  const result = await upstream.evaluate(session.page, code, evalArgs)
+  return { result }
+}
\ No newline at end of file
diff --git a/tools/interact.js b/tools/interact.js
new file mode 100644
index 0000000..87f76d7
--- /dev/null
+++ b/tools/interact.js
@@ -0,0 +1,23 @@
+import * as pool from '../core/pool.js'
+import * as upstream from '../upstream/wrapper.js'
+
+export const click = async args => {
+  const { id, selector } = args
+  const session = pool.get(id)
+  await upstream.click(session.page, selector)
+  return { success: true, selector }
+}
+
+export const type = async args => {
+  const { id, selector, text } = args
+  const session = pool.get(id)
+  await upstream.type(session.page, selector, text)
+  return { success: true, selector }
+}
+
+export const select = async args => {
+  const { id, selector, value } = args
+  const session = pool.get(id)
+  await upstream.select(session.page, selector, value)
+  return { success: true, selector, value }
+}
\ No newline at end of file
diff --git a/tools/navigate.js b/tools/navigate.js
new file mode 100644
index 0000000..78ddb21
--- /dev/null
+++ b/tools/navigate.js
@@ -0,0 +1,27 @@
+import * as pool from '../core/pool.js'
+import * as storage from '../core/storage.js'
+import * as upstream from '../upstream/wrapper.js'
+
+export const goto = async args => {
+  const { id, url, wait = 'domcontentloaded' } = args
+  const session = pool.get(id)
+
+  await upstream.navigate(session.page, url, { waitUntil: wait })
+  await storage.updateMeta(id, { lastUrl: url })
+
+  return { success: true, url }
+}
+
+export const back = async args => {
+  const { id } = args
+  const session = pool.get(id)
+  await upstream.back(session.page)
+  return { success: true }
+}
+
+export const forward = async args => {
+  const { id } = args
+  const session = pool.get(id)
+  await upstream.forward(session.page)
+  return { success: true }
+}
\ No newline at end of file
diff --git a/tools/session.js b/tools/session.js
new file mode 100644
index 0000000..3b2f8ea
--- /dev/null
+++ b/tools/session.js
@@ -0,0 +1,103 @@
+import { getBrowser } from '../upstream/wrapper.js'
+import * as pool from '../core/pool.js'
+import * as storage from '../core/storage.js'
+import { SessionExistsError } from '../utils/errors.js'
+import { navigate } from '../upstream/wrapper.js'
+import { VIEWPORT, USER_AGENT, LOCALE, TIMEZONE } from '../config.js'
+
+export const open = async args => {
+  const { id, url, config = {} } = args
+
+  if (pool.has(id)) {
+    throw new SessionExistsError(id)
+  }
+
+  await storage.ensureSessionsDir()
+
+  const browser = await getBrowser({ stealth: config.stealth !== false })
+  const state = await storage.loadState(id)
+
+  const context = await browser.newContext({
+    storageState: state || undefined,
+    viewport: config.viewport || VIEWPORT,
+    userAgent: config.userAgent || USER_AGENT,
+    locale: config.locale || LOCALE,
+    timezoneId: config.timezone || TIMEZONE,
+    // Inject scripts into all frames
+    javaScriptEnabled: true,
+  })
+
+  // Add init script to mask iframe fingerprints
+  await context.addInitScript(() => {
+    // Override iframe creation to inherit stealth
+    const originalCreateElement = document.createElement
+    document.createElement = function (tag) {
+      const el = originalCreateElement.call(document, tag)
+      if (tag.toLowerCase() === 'iframe') {
+        // Stealth is already applied by playwright-extra
+      }
+      return el
+    }
+  })
+
+  const page = await context.newPage()
+  pool.add(id, context, page)
+
+  const meta = {
+    id,
+    created: Date.now(),
+    lastUsed: Date.now(),
+    config,
+  }
+  await storage.saveMeta(id, meta)
+
+  if (url) {
+    await navigate(page, url)
+    await storage.updateMeta(id, { lastUrl: url })
+  }
+
+  return { success: true, id, url }
+}
+
+export const close = async args => {
+  const { id, save = true } = args
+  const session = pool.get(id)
+
+  if (save) {
+    const state = await session.context.storageState()
+    await storage.saveState(id, state)
+  }
+
+  await storage.updateMeta(id, { lastUsed: Date.now() })
+  await session.context.close()
+  pool.remove(id)
+
+  return { success: true, id }
+}
+
+export const list = async () => {
+  const active = pool.list()
+  const stored = await storage.listSessions()
+
+  const sessions = stored.map(id => {
+    const isActive = active.find(a => a.id === id)
+    return {
+      id,
+      active: !!isActive,
+      createdAt: isActive?.createdAt,
+    }
+  })
+
+  return { sessions }
+}
+
+export const deleteSession = async args => {
+  const { id } = args
+
+  if (pool.has(id)) {
+    await close({ id, save: false })
+  }
+
+  await storage.deleteSession(id)
+  return { success: true, id }
+}
diff --git a/tools/wait.js b/tools/wait.js
new file mode 100644
index 0000000..57a4fe1
--- /dev/null
+++ b/tools/wait.js
@@ -0,0 +1,28 @@
+import * as pool from '../core/pool.js'
+
+export const forClose = async args => {
+  const { id } = args
+  const session = pool.get(id)
+  
+  await session.page.waitForEvent('close', { timeout: 0 })
+  
+  return { success: true, message: 'Page closed by user' }
+}
+
+export const forSelector = async args => {
+  const { id, selector, timeout = 30000 } = args
+  const session = pool.get(id)
+  
+  await session.page.waitForSelector(selector, { timeout })
+  
+  return { success: true, selector }
+}
+
+export const forTimeout = async args => {
+  const { id, ms } = args
+  const session = pool.get(id)
+  
+  await session.page.waitForTimeout(ms)
+  
+  return { success: true, waited: ms }
+}
diff --git a/tools/workflow.js b/tools/workflow.js
new file mode 100644
index 0000000..007f9d4
--- /dev/null
+++ b/tools/workflow.js
@@ -0,0 +1,66 @@
+import * as pool from '../core/pool.js'
+import * as upstream from '../upstream/wrapper.js'
+import { TIMEOUT } from '../config.js'
+
+export const login = async args => {
+  const {
+    id,
+    username,
+    password,
+    usernameSelector = 'input[type="email"], input[name="username"], input[name="email"]',
+    passwordSelector = 'input[type="password"], input[name="password"]',
+    submitSelector = 'button[type="submit"], input[type="submit"]',
+  } = args
+
+  const session = pool.get(id)
+  const page = session.page
+
+  await upstream.type(page, usernameSelector, username)
+  await upstream.type(page, passwordSelector, password)
+  await upstream.click(page, submitSelector)
+
+  await page.waitForLoadState('networkidle', { timeout: TIMEOUT }).catch(() => { })
+
+  return { success: true }
+}
+
+export const fillForm = async args => {
+  const { id, fields } = args
+  const session = pool.get(id)
+  const page = session.page
+
+  for (const [selector, value] of Object.entries(fields)) {
+    const element = await page.$(selector)
+    if (!element) continue
+
+    const tagName = await element.evaluate(el => el.tagName.toLowerCase())
+
+    if (tagName === 'select') {
+      await upstream.select(page, selector, value)
+    } else {
+      await upstream.type(page, selector, value)
+    }
+  }
+
+  return { success: true, filled: Object.keys(fields).length }
+}
+
+export const scrape = async args => {
+  const { id, selectors } = args
+  const session = pool.get(id)
+  const page = session.page
+
+  const results = {}
+
+  for (const [key, selector] of Object.entries(selectors)) {
+    try {
+      const elements = await page.$$(selector)
+      const texts = await Promise.all(elements.map(el => el.textContent()))
+      results[key] = texts.filter(Boolean)
+    } catch {
+      results[key] = []
+    }
+  }
+
+  return { data: results }
+}
\ No newline at end of file
-- 
2.43.0

